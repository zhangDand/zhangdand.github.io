<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="七七八八">
<meta property="og:type" content="website">
<meta property="og:title" content="Zd's little box">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Zd's little box">
<meta property="og:description" content="七七八八">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zd's little box">
<meta name="twitter:description" content="七七八八">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> Zd's little box </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zd's little box</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">放一些无聊的 有趣的 七七八八的东西</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/14/webpack-简易教程/" itemprop="url">
                  webpack 简易教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-14T01:06:17+08:00" content="2016-10-14">
              2016-10-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Front-end/" itemprop="url" rel="index">
                    <span itemprop="name">Front-end</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Front-end/Webpack/" itemprop="url" rel="index">
                    <span itemprop="name">Webpack</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开始使用Webpack"><a href="#开始使用Webpack" class="headerlink" title="开始使用Webpack"></a>开始使用Webpack</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>webpack 可以使用 npm 进行安装</p>
<pre><code>//全局安装
npm install -g webpack
//文件夹下安装
npm install --save-dev webpack
</code></pre><h2 id="正式使用Webpack前的准备"><a href="#正式使用Webpack前的准备" class="headerlink" title="正式使用Webpack前的准备"></a>正式使用Webpack前的准备</h2><ol>
<li><p>在上述练习文件夹中创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件</p>
<pre><code>npm init
</code></pre><p> 输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。</p>
</li>
<li>package.json文件已经就绪，我们在本项目中安装webpack作为依赖包<pre><code>//安装webpack
npm install --save-dev webpack
</code></pre></li>
<li><p>回到之前的空文件夹，并在里面创建两个文件夹，app文件夹和public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。在这里还需要创建三个文件，index.html文件放在public文件夹中，两个js文件（greeter.js和main.js）放在app文件夹中，此时项目结构如下所示</p>
<pre><code>++webpacktest
    +node_modules
    +app
        -greeter.js
        -main.js
    +public
        -index.html
    -package.json
</code></pre><p> index.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js）</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Webpack Sample Project&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&apos;root&apos;&gt;
    &lt;/div&gt;
    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p> main.js用来把greeter模块返回的节点插入页面</p>
<pre><code>//main.js
var greeter = require(&apos;./Greeter.js&apos;);
document.getElementById(&apos;root&apos;).appendChild(greeter());
</code></pre><p> greeter.js只包括一个用来返回包含问候信息的html元素的函数</p>
<pre><code>// Greeter.js
module.exports = function() {
  var greet = document.createElement(&apos;div&apos;);
  greet.textContent = &quot;Hi there and greetings!&quot;;
  return greet;
};
</code></pre></li>
</ol>
<h1 id="正式使用Webpack"><a href="#正式使用Webpack" class="headerlink" title="正式使用Webpack"></a>正式使用Webpack</h1><p>webpack可以在终端中使用，其最基础的命令是</p>
<pre><code>webpack {emtry file/入口文件} {destination for bundled file/存放bundle.js 的地方}
//
webpack app/main.js public/bundle.js
</code></pre><p>需要指定一个入口文件，webpack将自动识别项目所依赖的其他文件，不过需要注意的是如果你的webpack没有进行全局安装，那么当你在终端中使用此命令时，需要额外指定其在node_modules中的地址，继续上面的例子，在终端中属于如下命令:</p>
<pre><code>//webpack非全局安装的情况
node_modules/.bin/webpack app/main.js public/bundle.js
</code></pre><p>##通过配置文件来使用webpack<br>Webpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。</p>
<p>还是继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，如下所示，它包含入口文件路径和存放打包后文件的地方的路径。</p>
<pre><code>module.exports = {
  entry:  __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件
  output: {
    path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方
    filename: &quot;bundle.js&quot;//打包后输出文件的文件名
  }
}
</code></pre><blockquote>
<p>注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p>
</blockquote>
<p>现在如果你需要打包文件只需要在终端里你运行<code>webpack(非全局安装需使用node_modules/.bin/webpack)</code>命令就可以了，这条命令会自动参考webpack.config.js文件中的配置选项打包你的项目,输出结果如下：</p>
<pre><code>Hash: 83742bda26ea3dfdbe01
Version: webpack 1.13.2
Time: 99ms
     Asset     Size  Chunks             Chunk Names
bundle2.js  1.74 kB       0  [emitted]  main
   [0] ./app/main.js 107 bytes {0} [built]
   [1] ./app/Greeter.js 161 bytes {0} [built]
</code></pre><p>当然，webpack也有办法连webpack这条命令都不用。</p>
<p>##更快捷的执行打包任务<br>执行类似于<code>node_modules/.bin/webpack</code>这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下。</p>
<pre><code>{
  &quot;name&quot;: &quot;webpack-sample-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Sample webpack project&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令
  },
  &quot;author&quot;: &quot;zhang&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^1.12.9&quot;
  }
}
</code></pre><blockquote>
<p>注：package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。</p>
</blockquote>
<p>npm的<code>start</code>是一个特殊的脚本名称，它的特殊性表现在，在命令行中使用<code>npm start</code>就可以执行相关命令，如果对应的此脚本名称不是<code>start</code>，想要在命令行中运行时，需要这样用<code>npm run {script name}如npm run build</code></p>
<h1 id="webpack的具体功能"><a href="#webpack的具体功能" class="headerlink" title="webpack的具体功能"></a>webpack的具体功能</h1><h2 id="生成source-maps"><a href="#生成source-maps" class="headerlink" title="生成source maps"></a>生成source maps</h2><p>开发总是离不开调试，如果可以更加方便的调试当然就能提高开发效率，不过打包后的文件有时候你是不容易找到出错了的地方对应的源代码的位置的，Source Maps就是来帮我们解决这个问题的。通过简单的配置后，Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。<br>在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下：</p>
<table>
<thead>
<tr>
<th>devtool选项</th>
<th>配置结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>source-map</td>
<td>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度；</td>
</tr>
<tr>
<td>cheap-module-source-map</td>
<td>在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；</td>
</tr>
<tr>
<td>eval-source-map</td>
<td>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项；</td>
</tr>
<tr>
<td>cheap-module-eval-source-map</td>
<td>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；</td>
</tr>
</tbody>
</table>
<p>如上所述，打包速度越快的，负面作用越多，基本就是功能和性能的取舍。</p>
<p>在学习阶段以及在小到中性的项目上，<code>eval-source-map</code>是一个很好的选项，不过记得只在开发阶段使用它，继续上面的例子，进行如下配置</p>
<pre><code>module.exports = {
  devtool: &apos;eval-source-map&apos;,//配置生成Source Maps，选择合适的选项
  entry:  __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/public&quot;,
    filename: &quot;bundle.js&quot;
  }
}
</code></pre><blockquote>
<p>cheap-module-eval-source-map方法构建速度更快，但是不利于调试，推荐在大型项目考虑da时间成本时使用。</p>
</blockquote>
<h2 id="使用webpack构架本地服务器"><a href="#使用webpack构架本地服务器" class="headerlink" title="使用webpack构架本地服务器"></a>使用webpack构架本地服务器</h2><p>想不想让你的浏览器监测你都代码的修改，并自动刷新修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖</p>
<pre><code>npm install --save-dev webpack-dev-server
</code></pre><p>devserver作为webpack配置选项中的一项，具有以下配置选项</p>
<table>
<thead>
<tr>
<th style="text-align:center">devserver 配置选项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">contentBase</td>
<td>默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public”目录）</td>
</tr>
<tr>
<td style="text-align:center">port</td>
<td>设置默认监听端口，如果省略，默认为”8080”</td>
</tr>
<tr>
<td style="text-align:center">inline</td>
<td>设置为<code>true</code> ，当源文件改变时会自动刷新页面</td>
</tr>
<tr>
<td style="text-align:center">colors</td>
<td>设置为 <code>true</code> ,使终端输出的文件为彩色的</td>
</tr>
<tr>
<td style="text-align:center">historyApiFallback</td>
<td>在开发单页应用时非常有用，它依赖于HTML5 history API ,如果设置为 <code>true</code> ，所有的跳转将指向index.html</td>
</tr>
</tbody>
</table>
<p>继续把这些命令加到webpack的配置文件中，现在的配置文件如下所示：</p>
<pre><code>module.exports = {
  devtool: &apos;eval-source-map&apos;,

  entry:  __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/public&quot;,
    filename: &quot;bundle.js&quot;
  },

  devServer: {
    contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录
    colors: true,//终端中输出结果为彩色
    historyApiFallback: true,//不跳转
    inline: true//实时刷新
  } 
}
</code></pre><h2 id="Lorders"><a href="#Lorders" class="headerlink" title="Lorders"></a>Lorders</h2><p>Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。</p>
<p>Loaders需要单独安装并且需要在webpack.config.js下的<code>modules</code>关键字下进行配置，Loaders的配置选项包括以下几方面：</p>
<ul>
<li><p><code>test</code>：一个匹配loaders所处理的文件的拓展名的正则表达式（必须）</p>
</li>
<li><p><code>loader</code>：<code>loader</code>的名称（必须）</p>
</li>
<li><p><code>include/exclude</code>:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</p>
</li>
<li><p><code>query</code>：为<code>loaders</code>提供额外的设置选项（可选）</p>
</li>
</ul>
<p>继续上面的例子，我们把Greeter.js里的问候消息放在一个单独的JSON文件里,并通过合适的配置使Greeter.js可以读取该JSON文件的值，配置方法如下</p>
<pre><code>//安装可以装换JSON的loader
npm install --save-dev json-loader



module.exports = {
  devtool: &apos;eval-source-map&apos;,

  entry:  __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/public&quot;,
    filename: &quot;bundle.js&quot;
  },

  module: {//在配置文件里添加JSON loader
    loaders: [
      {
        test: /\.json$/,
        loader: &quot;json&quot;
      }
    ]
  },

  devServer: {
    contentBase: &quot;./public&quot;,
    colors: true,
    historyApiFallback: true,
    inline: true
  }
}
</code></pre><p>创建带有问候信息的JSON文件，（命名为config.json）</p>
<pre><code>//config.json
{
  &quot;greetText&quot;: &quot;Hi there and greetings from JSON!&quot;
}
</code></pre><p>更新后的greeter.js</p>
<pre><code>var config = require(&apos;./config.json&apos;);

module.exports = function() {
  var greet = document.createElement(&apos;div&apos;);
  greet.textContent = config.greetText;
  return greet;
};
</code></pre><p>Loaders很好，不过有的Loaders使用起来比较复杂，比如说Babel。</p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的：</p>
<ul>
<li>下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持；</li>
<li>使用基于JavaScript进行了拓展的语言，比如React的JSX</li>
</ul>
<h3 id="Babel-的安装与配置"><a href="#Babel-的安装与配置" class="headerlink" title="Babel 的安装与配置"></a>Babel 的安装与配置</h3><p>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。</p>
<p>我们先来一次性安装这些依赖包</p>
<pre><code>// npm一次性安装多个依赖模块，模块之间用空格隔开
npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react
</code></pre><p>在webpack中配置Babel的方法如下</p>
<pre><code>module.exports = {
  devtool: &apos;eval-source-map&apos;,

  entry:  __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/public&quot;,
    filename: &quot;bundle.js&quot;
  },

  module: {
    loaders: [
      {
        test: /\.json$/,
        loader: &quot;json&quot;
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &apos;babel&apos;,//在webpack的module部分的loaders里进行配置即可
        query: {
          presets: [&apos;es2015&apos;,&apos;react&apos;]
        }
      }
    ]
  },

  devServer: {
    contentBase: &quot;./public&quot;,
    colors: true,
    historyApiFallback: true,
    inline: true
  }
}
</code></pre><p>现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM</p>
<pre><code>npm install --save react react-dom
</code></pre><p>使用ES6的语法，更新Greeter.js并返回一个React组件</p>
<pre><code>//Greeter,js
import React, {Component} from &apos;react&apos;
import config from &apos;./config.json&apos;;

class Greeter extends Component{
  render() {
    return (
      &lt;div&gt;
        {config.greetText}
      &lt;/div&gt;
    );
  }
}

export default Greeter
</code></pre><p>使用ES6的模块定义和渲染Greeter模块</p>
<pre><code>import React from &apos;react&apos;;
import {render} from &apos;react-dom&apos;;
import Greeter from &apos;./Greeter&apos;;

render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;));
</code></pre><h3 id="Babel的配置选项"><a href="#Babel的配置选项" class="headerlink" title="Babel的配置选项"></a>Babel的配置选项</h3><p>Babel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：</p>
<pre><code>// webpack.config.js
module.exports = {
  devtool: &apos;eval-source-map&apos;,

  entry:  __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/public&quot;,
    filename: &quot;bundle.js&quot;
  },

  module: {
    loaders: [
      {
        test: /\.json$/,
        loader: &quot;json&quot;
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &apos;babel&apos;
      }
    ]
  },

  devServer: {...} // Omitted for brevity
}


//.babelrc
{
  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]
}
</code></pre><p>到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。</p>
<h2 id="一切皆模块"><a href="#一切皆模块" class="headerlink" title="一切皆模块"></a>一切皆模块</h2><p>Webpack有一个不可不说的优点，它把所有的文件都可以当做模块处理，包括你的JavaScript代码，也包括CSS和fonts以及图片等等等，只有通过合适的loaders，它们都可以被当做模块被处理。</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>webpack提供两个工具处理样式表，<code>css-loader</code> 和 <code>style-loader</code>，二者处理的任务不同，<code>css-loader</code>使你能够使用类似<code>@import</code> 和 <code>url(...)</code>的方法实现 <code>require()</code>的功能,<code>style-loader</code>将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。</p>
<p>继续上面的例子</p>
<pre><code>//安装
npm install --save-dev style-loader css-loader
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//使用</div><div class="line">module.exports = &#123;</div><div class="line">  devtool: &apos;eval-source-map&apos;,</div><div class="line"></div><div class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/build&quot;,</div><div class="line">    filename: &quot;bundle.js&quot;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  module: &#123;</div><div class="line">    loaders: [</div><div class="line">      &#123;</div><div class="line">        test: /\.json$/,</div><div class="line">        loader: &quot;json&quot;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        exclude: /node_modules/,</div><div class="line">        loader: &apos;babel&apos;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: /\.css$/,</div><div class="line">        loader: &apos;style!css&apos;//添加对样式表的处理</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  devServer: &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：感叹号的作用在于使同一文件能够使用不同类型的loader</p>
</blockquote>
<p>接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式</p>
<pre><code>html {
  box-sizing: border-box;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
}

*, *:before, *:after {
  box-sizing: inherit;
}

body {
  margin: 0;
  font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif;
}

h1, h2, h3, h4, h5, h6, p, ul {
  margin: 0;
  padding: 0;
}
</code></pre><p>你还记得吗？webpack只有单一的入口，其它的模块需要通过 import, require, url等导入相关位置，为了让webpack能找到”main.css“文件，我们把它导入”main.js “中，如下</p>
<pre><code>//main.js
import React from &apos;react&apos;;
import {render} from &apos;react-dom&apos;;
import Greeter from &apos;./Greeter&apos;;

import &apos;./main.css&apos;;//使用require导入css文件

render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;));
</code></pre><blockquote>
<p>通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。<br>不过这也只是webpack把css当做模块而已，咱们继续看看一个真的CSS模块的实践。</p>
</blockquote>
<h3 id="CSS-module"><a href="#CSS-module" class="headerlink" title="CSS module"></a>CSS module</h3><p>在过去的一些年里，JavaScript通过一些新的语言特性，更好的工具以及更好的实践方法（比如说模块化）发展得非常迅速。模块使得开发者把复杂的代码转化为小的，干净的，依赖声明明确的单元，且基于优化工具，依赖管理和加载管理可以自动完成。不过前端的另外一部分，CSS发展就相对慢一些，大多的样式表却依旧是巨大且充满了全局类名，这使得维护和修改都非常困难和复杂。<br>最近有一个叫做 CSS modules 的技术就意在把JS的模块化思想带入CSS中来，通过CSS模块，所有的类名，动画名默认都只作用于当前模块。Webpack从一开始就对CSS模块化提供了支持，在CSS loader中进行配置后，你所需要做的一切就是把”modules“传递都所需要的地方，然后就可以直接把CSS的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中具有相同的类名可能会造成的问题。具体的代码如下</p>
<pre><code>module.exports = {
  devtool: &apos;eval-source-map&apos;,

  entry:  __dirname + &quot;/app/main.js&quot;,
  output: {...},

  module: {
    loaders: [
      {
        test: /\.json$/,
        loader: &quot;json&quot;
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &apos;babel&apos;
      },
      {
        test: /\.css$/,
        loader: &apos;style!css?modules&apos;//跟前面相比就在后面加上了?modules
      }
    ]
  },

  devServer: {...}
}
</code></pre><p>创建一个greeter.css文件</p>
<pre><code>.root {
  background-color: #eee;
  padding: 10px;
  border: 3px solid #ccc;
}
</code></pre><p>导入<code>.root</code> 到greeter.js中</p>
<pre><code>import React, {Component} from &apos;react&apos;;
import config from &apos;./config.json&apos;;
import styles from &apos;./Greeter.css&apos;;//导入

class Greeter extends Component{
  render() {
    return (
      &lt;div className={styles.root}&gt;//添加类名
        {config.greetText}
      &lt;/div&gt;
    );
  }
}

export default Greeter
</code></pre><p>放心使用把，相同的类名也不会造成不同组件之间的污染。<br>CSS modules 也是一个很大的主题，有兴趣的话可以去官方文档查看更多消息</p>
<h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p>Sass 和 Less之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句，你现在可能都已经熟悉了，在webpack里使用相关loaders进行配置就可以使用了，以下是常用的CSS 处理loaders</p>
<ul>
<li>Less Loader</li>
<li>Sass Loader</li>
<li>Stylus Loader</li>
</ul>
<p>不过其实也存在一个CSS的处理平台-PostCSS，它可以帮助你的CSS实现更多的功能，在其<a href="https://github.com/postcss/postcss/" title="css 官方文档 github" target="_blank" rel="external">CSS官方文档</a>可了解更多相关知识。</p>
<p>举例来说如何使用PostCSS，我们使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀。</p>
<p>首先安装postcss-loader 和 autoprefixer（自动添加前缀的插件）</p>
<pre><code>npm install --save-dev postcss-loader autoprefixer
</code></pre><p>接下来，在webpack配置文件中进行设置，只需要新建一个postcss关键字，并在里面申明依赖的插件，如下，现在你写的css会自动根据Can i use里的数据添加不同前缀了。</p>
<pre><code>//webpack配置文件
module.exports = {
  devtool: &apos;eval-source-map&apos;,
  entry: __dirname + &quot;/app/main.js&quot;,
  output: {...},

  module: {
    loaders: [
      {
        test: /\.json$/,
        loader: &quot;json&quot;
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &apos;babel&apos;
      },
      {
        test: /\.css$/,
        loader: &apos;style!css?modules!postcss&apos;
      }
    ]
  },

  postcss: [
    require(&apos;autoprefixer&apos;)//调用autoprefixer插件
  ],

  devServer: {...}
}
</code></pre><p>到现在，本文已经涉及到处理JS的Babel和处理CSS的PostCSS，它们其实也是两个单独的平台，配合Webpack可以很好的发挥它们的作用。接下来介绍Webpack中另一个非常重要的功能-Plugins</p>
<h2 id="插件（Plugins）"><a href="#插件（Plugins）" class="headerlink" title="插件（Plugins）"></a>插件（Plugins）</h2><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。<br>Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<h3 id="使用插件的方法"><a href="#使用插件的方法" class="headerlink" title="使用插件的方法"></a>使用插件的方法</h3><p>要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续看例子，我们添加了一个实现版权声明的插件。</p>
<pre><code>//webpack.config.js
var webpack = require(&apos;webpack&apos;);

module.exports = {
  devtool: &apos;eval-source-map&apos;,
  entry:  __dirname + &quot;/app/main.js&quot;,
  output: {...},

  module: {
    loaders: [
      { test: /\.json$/, loader: &quot;json&quot; },
      { test: /\.js$/, exclude: /node_modules/, loader: &apos;babel&apos; },
      { test: /\.css$/, loader: &apos;style!css?modules!postcss&apos; }//这里添加PostCSS
    ]
  },
  postcss: [
    require(&apos;autoprefixer&apos;)
  ],

  plugins: [
    new webpack.BannerPlugin(&quot;Copyright Flying Unicorns inc.&quot;)//在这个数组中new一个就可以了
  ],

  devServer: {...}
}
</code></pre><h3 id="常用的插件"><a href="#常用的插件" class="headerlink" title="常用的插件"></a>常用的插件</h3><h4 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h4><p>这个插件的作用是依据一个简单的模板，帮你生成最终的Html5文件，这个文件中自动引用了你打包后的JS文件。每次编译都在文件名中插入一个不同的哈希值。</p>
<p>安装</p>
<pre><code>npm install --save-dev html-webpack-plugin
</code></pre><p>这个插件自动完成了我们之前手动做的一些事情，在正式使用之前需要对一直以来的项目结构做一些改变：</p>
<ol>
<li>移除public文件夹，利用此插件，HTML5文件会自动生成，此外CSS已经通过前面的操作打包到JS中了，public文件夹里。</li>
<li><p>在app目录下，创建一个Html文件模板，这个模板包含title等其它你需要的元素，在编译过程中，本插件会依据此模板生成最终的html页面，会自动添加所依赖的 css, js，favicon等文件，在本例中我们命名模板文件名称为index.tmpl.html，模板源代码如下</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Webpack Sample Project&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&apos;root&apos;&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>更新webpack的配置文件，方法同上,新建一个build文件夹用来存放最终的输出文件</p>
<pre><code>var webpack = require(&apos;webpack&apos;);
var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
  devtool: &apos;eval-source-map&apos;,

  entry:  __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/build&quot;,
    filename: &quot;bundle.js&quot;
  },

  module: {
    loaders: [
      { test: /\.json$/, loader: &quot;json&quot; },
      { test: /\.js$/, exclude: /node_modules/, loader: &apos;babel&apos; },
      { test: /\.css$/, loader: &apos;style!css?modules!postcss&apos; }
    ]
  },
  postcss: [
    require(&apos;autoprefixer&apos;)
  ],

  plugins: [
    new HtmlWebpackPlugin({
      template: __dirname + &quot;/app/index.tmpl.html&quot;//new 一个这个插件的实例，并传入相关的参数
    })
  ],

  devServer: {
    colors: true,
    historyApiFallback: true,
    inline: true
  }
}
</code></pre><h4 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h4><p>Hot Module Replacement（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。<br>在webpack中实现HMR也很简单，只需要做两项配置</p>
</li>
<li><p>在webpack配置文件中添加HMR插件；</p>
</li>
<li>在Webpack Dev Server中添加“hot”参数；</li>
</ol>
<p>不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在你的JS模块中执行一个Webpack提供的API才能实现热加载，虽然这个API不难使用，但是如果是React模块，使用我们已经熟悉的Babel可以更方便的实现功能热加载。</p>
<p>整理下我们的思路，具体实现方法如下</p>
<ul>
<li>Babel和webpack是独立的工具</li>
<li>二者可以一起工作</li>
<li>二者都可以通过插件拓展功能</li>
<li>HMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额；</li>
<li>Babel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作；</li>
</ul>
<p>更新我们的例子来实际看看如何配置</p>
<pre><code>//webpack中的配置
var webpack = require(&apos;webpack&apos;);
var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
  devtool: &apos;eval-source-map&apos;,
  entry: __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/build&quot;,
    filename: &quot;bundle.js&quot;
  },

  module: {
    loaders: [
      { test: /\.json$/, loader: &quot;json&quot; },
      { test: /\.js$/, exclude: /node_modules/, loader: &apos;babel&apos; },
      { test: /\.css$/, loader: &apos;style!css?modules!postcss&apos; }
    ]
  },
  postcss: [
    require(&apos;autoprefixer&apos;)
  ],

  plugins: [
    new HtmlWebpackPlugin({
      template: __dirname + &quot;/app/index.tmpl.html&quot;
    }),
    new webpack.HotModuleReplacementPlugin()//热加载插件
  ],

  devServer: {
    colors: true,
    historyApiFallback: true,
    inline: true,
    hot: true
  }
}
</code></pre><p>安装react-transform-hmr</p>
<pre><code>npm install --save-dev babel-plugin-react-transform react-transform-hmr
</code></pre><p>配置Babel</p>
<pre><code>{
  &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;],
  &quot;env&quot;: {
    &quot;development&quot;: {
    &quot;plugins&quot;: [[&quot;react-transform&quot;, {
       &quot;transforms&quot;: [{
         &quot;transform&quot;: &quot;react-transform-hmr&quot;,

         &quot;imports&quot;: [&quot;react&quot;],

         &quot;locals&quot;: [&quot;module&quot;]
       }]
     }]]
    }
  }
}
</code></pre><p>现在当你使用React时，可以热加载模块了</p>
<h2 id="产品阶段的构建"><a href="#产品阶段的构建" class="headerlink" title="产品阶段的构建"></a>产品阶段的构建</h2><p>目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。<br>对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个“webpack.production.config.js”的文件，在里面加上基本的配置,它和原始的webpack.config.js很像，如下</p>
<pre><code>var webpack = require(&apos;webpack&apos;);
var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);

module.exports = {
  entry: __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/build&quot;,
    filename: &quot;bundle.js&quot;
  },

  module: {
    loaders: [
      {
        test: /\.json$/,
        loader: &quot;json&quot;
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &apos;babel&apos;
      },
      {
        test: /\.css$/,
        loader: &apos;style!css?modules!postcss&apos;
      }
    ]
  },
  postcss: [
    require(&apos;autoprefixer&apos;)
  ],

  plugins: [
    new HtmlWebpackPlugin({
      template: __dirname + &quot;/app/index.tmpl.html&quot;
    }),
  ],

}
</code></pre><p>.</p>
<pre><code>//package.json
{
  &quot;name&quot;: &quot;webpack-sample-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Sample webpack project&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --progress&quot;,
    &quot;build&quot;: &quot;NODE_ENV=production webpack --config ./webpack.production.config.js --progress&quot;
  },
  &quot;author&quot;: &quot;Cássio Zen&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {...},
  &quot;dependencies&quot;: {...}
}
</code></pre><h3 id="优化插件"><a href="#优化插件" class="headerlink" title="优化插件"></a>优化插件</h3><p>webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能</p>
<ul>
<li>OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID</li>
<li>UglifyJsPlugin：压缩JS代码；</li>
<li>ExtractTextPlugin：分离CSS和JS文件</li>
</ul>
<p>我们继续用例子来看看如何添加它们，OccurenceOrder 和 UglifyJS plugins 都是内置插件，你需要做的只是安装它们</p>
<pre><code>npm install --save-dev extract-text-webpack-plugin
</code></pre><p>在配置文件的plugins后引用它们</p>
<pre><code>var webpack = require(&apos;webpack&apos;);
var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);

module.exports = {
  entry: __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/build&quot;,
    filename: &quot;bundle.js&quot;
  },

  module: {
    loaders: [
      {
        test: /\.json$/,
        loader: &quot;json&quot;
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &apos;babel&apos;
      },
      {
        test: /\.css$/,
        loader: ExtractTextPlugin.extract(&apos;style&apos;, &apos;css?modules!postcss&apos;)
      }
    ]
  },
  postcss: [
    require(&apos;autoprefixer&apos;)
  ],

  plugins: [
    new HtmlWebpackPlugin({
      template: __dirname + &quot;/app/index.tmpl.html&quot;
    }),
    new webpack.optimize.OccurenceOrderPlugin(),
    new webpack.optimize.UglifyJsPlugin(),
    new ExtractTextPlugin(&quot;style.css&quot;)
  ]
}
</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）<br>webpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前</p>
<pre><code>var webpack = require(&apos;webpack&apos;);
var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);

module.exports = {
  entry: __dirname + &quot;/app/main.js&quot;,
  output: {
    path: __dirname + &quot;/build&quot;,
    filename: &quot;[name]-[hash].js&quot;
  },

  module: {
    loaders: [
      {
        test: /\.json$/,
        loader: &quot;json&quot;
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &apos;babel&apos;
      },
      {
        test: /\.css$/,
        loader: ExtractTextPlugin.extract(&apos;style&apos;, &apos;css?modules!postcss&apos;)
      }
    ]
  },
  postcss: [
    require(&apos;autoprefixer&apos;)
  ],

  plugins: [
    new HtmlWebpackPlugin({
      template: __dirname + &quot;/app/index.tmpl.html&quot;
    }),
    new webpack.optimize.OccurenceOrderPlugin(),
    new webpack.optimize.UglifyJsPlugin(),
    new ExtractTextPlugin(&quot;[name]-[hash].css&quot;)
  ]
}
</code></pre><p>现在用户会有合理的缓存了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/22/web前端工作的范围和误区/" itemprop="url">
                  web前端工作的范围和误区
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-22T10:40:10+08:00" content="2016-09-22">
              2016-09-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Front-end/" itemprop="url" rel="index">
                    <span itemprop="name">Front-end</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Front-end/Concept/" itemprop="url" rel="index">
                    <span itemprop="name">Concept</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="初学者总是对前端有一定的误区，认为前端开发是一个「相对于其他技术来说更简单的技术」，在他们心中前端工程师式这样工作的："><a href="#初学者总是对前端有一定的误区，认为前端开发是一个「相对于其他技术来说更简单的技术」，在他们心中前端工程师式这样工作的：" class="headerlink" title="初学者总是对前端有一定的误区，认为前端开发是一个「相对于其他技术来说更简单的技术」，在他们心中前端工程师式这样工作的："></a>初学者总是对前端有一定的误区，认为前端开发是一个「相对于其他技术来说更简单的技术」，在他们心中前端工程师式这样工作的：</h5><ol>
<li>把 Photoshop 文件、图片或者线框放进一个网页；</li>
<li>偶尔设计 Photoshop 文件、图片或者线框；</li>
<li>用 JS 编程，为网页制作动画、过渡效果；</li>
<li>用 HTML 和 CSS 编程，确定网页的内容和形式。</li>
</ol>
<h5 id="事实上-前端工程师需要做的是："><a href="#事实上-前端工程师需要做的是：" class="headerlink" title="事实上,前端工程师需要做的是："></a><strong>事实上</strong>,前端工程师需要做的是：</h5><ol>
<li>在设计师和工程师之间创建可视化的语言；</li>
<li>用可视化的设计，定义一组代表内容、品牌和功能的组件；</li>
<li>为 Web 应用程序的公约、框架、需求、可视化的语言和规格设定底线；</li>
<li>定义 Web 应用程序的设备、浏览器、屏幕、动画的范围；</li>
<li>开发一个质量保证指南来确保品牌忠诚度、代码质量、产品标准；</li>
<li>为 Web 应用程序设定适当的行距、字体、标题、图标、边距、填充等等；</li>
<li>为 Web 应用程序设定多种分辨率的图像，设备为主的实体模型，同时维护设计指南；</li>
<li>用 account semantics, accessibility, SEO, schemas ，microformats 标记 Web 应用程序；</li>
<li>用一种友好的，消耗小的，设备和客户端感知的方式连接 API，获取内容；</li>
<li>开发客户端代码来显示流畅的动画、过渡、延迟加载、交互、应用工作流程，大多数时间用来考虑渐进增强和向后兼容的标准；</li>
<li>保证后台连接安全，采取跨地资源共享（CORS）的程序考虑，防止跨站点脚本（XSS）和跨站点请求伪造（CSRF） ；</li>
<li>最重要的是，尽管有严格的期限、利益相关者的要求，以及设备的限制，无论现在还是将来永远是「客户第一」。</li>
</ol>
<h5 id="由于这种误区的存在，导致了前端市场的野蛮生长，一些不太好的前端会使用不那么聪明手段去完成需求："><a href="#由于这种误区的存在，导致了前端市场的野蛮生长，一些不太好的前端会使用不那么聪明手段去完成需求：" class="headerlink" title="由于这种误区的存在，导致了前端市场的野蛮生长，一些不太好的前端会使用不那么聪明手段去完成需求："></a>由于这种误区的存在，导致了前端市场的野蛮生长，一些不太好的前端会使用不那么聪明手段去完成需求：</h5><ol>
<li>JavaScript 类库乱用，对 JavaScript 本身并不了解，什么地方都用 jQuery；</li>
<li>滥用 JavaScript 插件，看都不看看就把别人的代码拿过来用，比如说；</li>
<li>不看需求，不做任何的比较和测试，就把CSS 框架加到项目中，但只用了其中 5% 的功能；</li>
<li>认为添加个 CSS Framework，网站就可以变成“响应式的”，或者响应式就像是一些小作料，随便就可以加入到一个网页应用中；</li>
<li>嘴上喊着“响应式的 Web 设计”，但服务端技术一点都不懂；</li>
<li>编写的 CSS 没有任何规范标准，不使用任何预处理器，也没有最佳实践。CSS 代码中充满了过度使用的选择器、ID、神奇的数字以及 !important；</li>
<li>不关心代码的性能和内存泄露（什么是真正的内存泄露也不清楚）,不会对代码进行性能测试；</li>
<li>对产品没有任何的衡量指标，或者把“在我的电脑/浏览器/移动设备上可以工作”为指标；</li>
<li>忽视30年的软件工程实践，毫无章法的开发软件。</li>
</ol>
<p>如果上述那些做法全程参与到项目的构建中的话，会非常不利于项目的后期维护和性能优化，毕竟在工程角度，这些做法都是非常野蛮而不优雅的，所以市场上才会非常缺少优秀的前端。</p>
<p><em>入门容易精通难。</em>一位优秀的前端工程师不仅要考虑web技术和语言，并且还要了解所有不同的组件、系统和概念。</p>
<h5 id="成熟前端工程师需要具备很多的经验和实践："><a href="#成熟前端工程师需要具备很多的经验和实践：" class="headerlink" title="成熟前端工程师需要具备很多的经验和实践："></a>成熟前端工程师需要具备很多的经验和实践：</h5><p>  1.了解 DNS 解析，充分利用CDN，使用多个域名来完成资源的请求以缩短加载时间；</p>
<ol>
<li>设置 HTTP Headers（Expires, Cache-Control, If-Modified-Since）；</li>
<li>遵循 Steve Souders 给出的全部规则（High Performance Websites）知道如何解决 PageSpeed、YSlow、Chrome Dev Tools Audit、Chrome Dev Tools Timeline 显示的所有问题；</li>
<li>知道什么任务该放在服务端，什么任务该放在客户端；</li>
<li>知道使用缓存，DNS 预取和资源预加载技巧；</li>
<li>精通 JavaScript，知道何时自己写何时借组别人的框架或代码，优劣明辨；</li>
<li>熟练使用现代 MVC JavaScript 框架（例如 AngularJS EmberJS React 等），图形库（D3、SnapSVG 等），DOM 操作类库（jQuery、Zepto 等），惰性加载或者模块管理类库（例如 RequireJS、CommonJS 等），任务调用工具（例如 Grunt Gulp 等），包管理工具（Bower Componentjs）以及测试工具（Protractor、Selenium 等）；</li>
<li>掌握图片的格式，每种格式的优点，适用的场景；</li>
<li>知道图片优化技巧以及加载策略（雪碧图、懒加载、缓存刷新以及 PNG 交错）；</li>
<li>熟悉 CSS 标准、最新的转换工具积极策略规范（比如 BEM、SMACSS、OOCSS 等）；</li>
<li>JavaScript 的计算机科学（内存管理、单进程特性、垃圾回收算法、定时器、作用域、提升以及设计模式）。</li>
</ol>
<blockquote>
<p>部分内容来源于<a href="https://zhuanlan.zhihu.com/p/20598089" target="_blank" rel="external">知乎</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/22/Git远程仓库设置方法/" itemprop="url">
                  Git远程仓库设置方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-22T00:31:22+08:00" content="2016-09-22">
              2016-09-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍四个远程仓库常用命令"><a href="#介绍四个远程仓库常用命令" class="headerlink" title="介绍四个远程仓库常用命令"></a>介绍四个远程仓库常用命令</h2><ul>
<li><code>git remote</code> 添加远程映射</li>
<li><code>git fetch</code> 添加远程分支到本地</li>
<li><code>git pull</code> 将远程分支合并到本地</li>
<li><code>git clone</code> 直接复制仓库到本地</li>
</ul>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a><code>git remote</code></h3><ul>
<li><code>git remote add origin ~/git-server</code> 添加一个远程仓库别名,默认是<code>origin</code>，可以进行改变。</li>
<li><code>git remote -v</code> 查看远程信息</li>
</ul>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a><code>git fetch</code></h3><ul>
<li><code>git fetch origin master</code> 从远程获取最新版本到本地，不会自动merge<br>使用这个命令可以用 <code>git diff master</code> 查询远程库的更新项目，以更好的追踪变化，比起<code>git pull</code> 更加适合日常使用场景</li>
<li>在<code>git fetch</code> 使用之后确定变动后可以使用 <code>git merge origin/master</code> 进行合并</li>
<li>通过<code>git branch -r</code> 可以查看当前的远程分支情况</li>
</ul>
<h5 id="git-pull-通常使用在不需要检查变动的远程库合并"><a href="#git-pull-通常使用在不需要检查变动的远程库合并" class="headerlink" title="git pull 通常使用在不需要检查变动的远程库合并"></a><code>git pull</code> 通常使用在不需要检查变动的远程库合并</h5><h5 id="git-clone-直接复制远程库，会直接设置远程库的历史版本和分支记录"><a href="#git-clone-直接复制远程库，会直接设置远程库的历史版本和分支记录" class="headerlink" title="git clone 直接复制远程库，会直接设置远程库的历史版本和分支记录"></a><code>git clone</code> 直接复制远程库，会直接设置远程库的历史版本和分支记录</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/markdown基础语法/" itemprop="url">
                  markdown基础语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T00:43:28+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/MarkDown/" itemprop="url" rel="index">
                    <span itemprop="name">MarkDown</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h1><ul>
<li><p><em>段落</em>需要一个或一个以上的空行来标识</p>
</li>
<li><p><code>#</code>  <em>标题</em>符号<br><code>=====</code>  顶格一串  上一行字符为标题</p>
</li>
<li><p><code>&gt;</code> 表示<em>区块引用</em>，允许在段落第一行写一个</p>
</li>
<li><p><code>*</code> <code>+</code> <code>-</code> 三个都可以用来表示<em>无序列表</em></p>
</li>
<li><p><code>num.</code>  数字后加<code>.</code>可以表示<em>有序列表</em>  <code>e.g. 1.</code></p>
</li>
<li><p><em>代码区块</em>  4个空格或者一个制表符就可以，代码区块中，markdown语法同样不会被转换</p>
</li>
<li><p><code>***</code> <code>---</code> <code>___</code> <em>分割线</em>，可以用三个以上的该符号来建立，一行中不能有其他字符，但可以插入空格</p>
</li>
</ul>
<h1 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h1><ul>
<li><p><code>[链接名](url)</code>  <em>链接</em>的写法</p>
<p><code>[参考式][id]</code><br><code>[id]: &lt;http://example.com/&gt; &quot;optional title here&quot;</code> 用这种组合形式的参考式来插入链接，前者定义连接的位置和id，后者定义链接的内容</p>
</li>
<li><p><code>*&lt;content&gt;*</code> <code>_&lt;content&gt;_</code> MarkDown使用 星号<code>*</code> 和 底线<code>_</code>作为标记<em>强调</em>符号，被这两个符号保卫的自此会被转成<code>&lt;em&gt;</code>标签包围，用两个这种符号 被转成<code>&lt;strong&gt;</code>  <em>em样式</em>  <strong>strong样式</strong></p>
</li>
<li><p><code>`` </code> 标记<em>行内代码</em>,用反引号包裹</p>
</li>
<li><p><code>![alt text](/path/to/img.jpg)</code><br><code>![alt text](/path/to/img.jpg &quot;optional title&quot;)</code><br><em>图片</em>的表示类似链接<br>参考式图片语法<br><code>![alt text][id]</code><br><code>[id]: url/to/image &quot;optional title attribute&quot;</code></p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/hexo常用命令/" itemprop="url">
                  hexo常用命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T00:18:06+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hexo/Command/" itemprop="url" rel="index">
                    <span itemprop="name">Command</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="记录一些hexo的常用命令"><a href="#记录一些hexo的常用命令" class="headerlink" title="记录一些hexo的常用命令"></a>记录一些hexo的常用命令</h2><h3 id="常用简写"><a href="#常用简写" class="headerlink" title="常用简写"></a>常用简写</h3><ul>
<li><code>hexo n</code> 新建文章</li>
<li><code>hexo g</code> 新建页面</li>
<li><code>hexo d</code> 部署</li>
<li><code>hexo s</code> 本地端口</li>
<li><code>hexo d -g</code> 生成加部署</li>
<li><code>hexo s -g</code> 预览加部署
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/09/21/hexo常用命令/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/13/hexo-next-界面设置相关/" itemprop="url">
                  hexo-next 界面设置相关
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-13T21:39:22+08:00" content="2016-09-13">
              2016-09-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Hexo/Next/" itemprop="url" rel="index">
                    <span itemprop="name">Next</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>hexo文章头部写法、设置标签页、设置分类页、</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/09/13/hexo-next-界面设置相关/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/bakeneko.jpg"
               alt="zhangDand" />
          <p class="site-author-name" itemprop="name">zhangDand</p>
          <p class="site-description motion-element" itemprop="description">七七八八</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhangDand" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://zhangdand.github.io/dan_demo/resume/dan_resume.html" target="_blank" title="Resume">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Resume
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangDand</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
